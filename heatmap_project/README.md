# Heatmap KDE Project

В этом проекте:
- create_simple_screen.py — скрипт для создания белого фонового изображения simple_screen.png
- main.py — основной код, который генерирует данные, считает KDE и накладывает тепловую карту.

<!-- ## Установка зависимостей
pip install -r requirements.txt -->

## Шаги запуска
1. python3 create_simple_screen.py
   (создаст simple_screen.png, если у вас нет другого фонового изображения)
2. python3 main.py
   (сгенерирует тепловую карту, наложит её на simple_screen.png и сохранит как result_heatmap.png)



## 11. Оценка асимптотической сложности

- Brute force: O(M × N), где M — количество ячеек сетки, N — число точек...
- Accumulate: O(N × R²), где R — радиус области влияния (зависящий от bandwidth и grid_spacing)...


- **Brute force**  
  Пусть \(N\) – общее число точек (напр., 200 респондентов × 2000 точек = 400000).  
  Пусть \(M\) – число ячеек в сетке (\(\text{grid\_width} \times \text{grid\_height}\)).  
  Тогда сложность ~\(\mathcal{O}(M \times N)\).

- **Accumulate**  
  Пусть \(R\) – количество ячеек, попадающих в «радиус влияния» (зависит от \(\text{bandwidth}\) и \(\text{grid\_spacing}\)).  
  Тогда сложность ~\(\mathcal{O}(N \times R^2)\).



<!-- 
Шаг 11. Оценка асимптотической сложности

    Brute force:
        Пусть NN – общее число точек (например, 200 респондентов × 2000 точек = 400000).
        Пусть MM – число ячеек в сетке (grid_width×grid_heightgrid_width×grid_height).
        Каждый расчёт плотности делает вклад от каждой точки к каждой ячейке, значит O(N×M)O(N×M).
        Если размеры изображения большие, и сетка мелкая, MM растёт, что может сильно замедлять алгоритм.

    Accumulate:
        При этом методе мы для каждой точки вносим вклад только в ячейки внутри радиуса ≈3×bandwidth≈3×bandwidth.
        Если RR – число ячеек по горизонтали/вертикали в радиусе (примерно 3×bandwidthgrid_spacinggrid_spacing3×bandwidth​), то сложность O(N×R2)O(N×R2).
        При разумном выборе grid_spacing и bandwidth может оказаться быстрее, чем полный перебор. -->




